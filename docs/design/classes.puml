@startuml RiskDesign

package presentation {
    +class Main {
        +{static} main(args: String[]): void
        +start(): void
    }

    +interface GenericUI {
        +draw(): void
    }

    +class ConcreteUI {

    }

    ConcreteUI .u.|> GenericUI

    +interface GenericController {
        +receiveInput(): void
    }

    +class ConcreteController {

    }

    ConcreteController .u.|> GenericController

    +class PlayerDisplay {

    }


}

package domain {
    +abstract class GameEngine {
        ~gamePhase: GamePhase
        ~gameGraph: TerritoryGraph
        ~tradeInChecker: TradeInManager
        ~riskCardDeck: RiskCardDeck
        ~dieRollParser: DieRollParser

    }

    +class WorldDomination {

    }

    +class SecretMission {

    }

    +class CapitalRisk {

    }

    +enum GamePhase {
        GAME_START,
        SETUP,
        PLACEMENT,
        ATTACK,
        FORTIFY,
        GAME_OVER
    }

    GameEngine --> GamePhase
    GameEngine --> TerritoryGraph
    GameEngine --> RiskCardDeck
    GameEngine --> TradeInParser
    GameEngine --> DieRollParser

    CapitalRisk --|> GameEngine
    SecretMission --|> GameEngine
    WorldDomination --|> GameEngine

    +class RiskCardDeck {
        -deckOfCards: List<Card>
        +RiskCardDeck()
        +drawCardFromDeck(): Card
        +initializeDeck(): boolean
        -shuffleDeck(): boolean
    }

    +class Die {
        -maximumPossibleRoll: int
        -minimumPossibleRoll: int
        +Die(maximumPossibleRoll: int, minimumPossibleRoll: int)
        +rollSingleDie(randomizer: Random): Integer

        // {method} the below constructor is for unit testing purposes only!
        ~Die()
    }

    +class DieRollParser {
        -{final} attackerDice: List<Die>
        -{final} defenderDice: List<Die>
        -{final}randomizer: Random
        -setupDie: Die
        +DieRollParser()
        +buildDiceLists(): boolean

        +rollDiceToDeterminePlayerOrder(amountOfDiceToRoll: int): List<Integer>
        -buildSetupDie(setupDieUpperBound: int): void

        +rollAttackerDice(amountOfDiceToRoll: int): List<Integer>
        +rollDefenderDice(amountOfDiceToRoll: int): List<Integer>
        -validateRequestedAmountOfDiceToRollIsInRange(requestedAmount: int, minAllowedAmount: int, maxAllowedAmount: int): void
        -rollDiceFromList(amountOfDiceToRoll: int, List<Die> listToUse)

        +generateBattleResults(defenderRolls: List<Integer>, attackerRolls: List<Integer>): List<BattleResult>
        -validateListsAreNotEmpty(defenderRollsList: List<Integer>, attackerRollsList: List<Integer>): void
        -validateListsAreSortedProperly(defenderRollsList: List<Integer>, attackerRollsList: List<Integer>): void
        -calculateBattleResult(defenderRoll: Integer, attackerRoll: Integer): BattleResult
        ~validateSortIsInNonIncreasingOrder(toCheck: List<Integer>): boolean

        // {method} the below constructor is for unit testing purposes only!
        ~DieRollParser(randomizer: Random, attackerDice: List<Die>, defenderDice: List<Die>)
    }

    DieRollParser --> "*" Die
    DieRollParser ..> BattleResult

    +enum BattleResult {
        ATTACKER_VICTORY,
        DEFENDER_VICTORY
    }

    RiskCardDeck --> "*" Card

    +class TradeInParser {
        -setsTradedInSoFar: int
        +TradeInParser()
        +startTrade(attemptedCards: List<Card>): int
        -verifyValidCombo(attemptedCards: List<Card>): boolean
        -calculateNumNewPieces(attemptedCards: List<Card>): int
        -updateSetsTradedIn(attemptedCards: List<Card>): boolean
    }

    TradeInParser .d.> Card

    +class Player {
        -cards: Set<Card>
        -pieces: Set<Piece>
        -color: PlayerColor
    }

    Player -u-> "*" Piece
    Player -u-> "*" Card
    Player -u-> PlayerColor

    +class Piece {
        -pieceType: PieceType
    }

    +enum PieceType {
        ARTILLERY,
        CAVALRY,
        INFANTRY
    }

    Piece --> PieceType

    +interface Card {
        +isWild(): boolean
        +matchesTerritory(territory: TerritoryType): boolean
        +matchesPieceType(pieceType: PieceType): boolean
    }

    +class WildCard {
        +matchesTerritory(territory: TerritoryType): boolean
        +matchesPieceType(pieceType: PieceType): boolean
        +isWild(): boolean
    }

    note "matchesPieceType and isWild returns true, matchesTerritory returns false" as N1
    N1 .u. WildCard

    +class TerritoryCard {
        -territoryType: TerritoryType
        -pieceType: PieceType
        +matchesTerritory(territory: TerritoryType): boolean
        +matchesPieceType(pieceType: PieceType): boolean
        +isWild(): boolean
    }

    +class SecretMissionCard {
        // behaves a little differently        
    }

    TerritoryCard ..|> Card
    WildCard ..|> Card
    TerritoryCard --> PieceType
    TerritoryCard --> TerritoryType

    +enum TerritoryType {
        ...
    }

    +enum Continent {
        NORTH_AMERICA,
        SOUTH_AMERICA,
        ...
    }

    +class TerritoryGraph {
        -territories: Map<TerritoryType, Set<Territory>>
        -territoryTypeToObject: Map<TerritoryType, Territory>
        +TerritoryGraph()

        +addNewTerritory(territory: Territory): boolean
        +addNewAdjacency(startingTerritory: TerritoryType, endingTerritory: TerritoryType): boolean
        -isValidAdjacency(startingTerritory: TerritoryType, endingTerritory: TerritoryType): boolean

        +addSetOfAdjacencies(keyToAddOn: TerritoryType, adjTerritories: Set<Territory>): boolean
        -graphContainsAdjacencies(territoryType: TerritoryType, adjacencies: Set<TerritoryType>, currentAdjacencies: Set<TerritoryType>): boolean
        -graphHasAdjacencyMapping(adjacencies: Set<TerritoryType>, currentAdjacencies: Set<TerritoryType>): boolean
        -addAdjacenciesToGraph(territory: TerritoryType, adjacencies: Set<TerritoryType>, currentAdjacencies: Set<TerritoryType>): void
    }

    TerritoryGraph --> "*" Territory
    TerritoryGraph --> "*" TerritoryType
    TerritoryGraph ..> Territory
    TerritoryGraph ..> TerritoryType

    +class Territory {
        -territoryType: TerritoryType
        -playerInControl: PlayerColor
        -numArmiesPresent: int
        -continent: Continent
        +Territory(territoryType: TerritoryType)
        +setPlayerInControl(newPlayer: Player): boolean 
        +setNumArmiesPresent(newAmount: int): boolean
        +getPlayerInControl(): Player
        +getArmies(): int
        +getTerritoryType(): TerritoryType
    }

    Territory --> PlayerColor
    Territory --> TerritoryType
    Territory -> Continent

    +enum PlayerColor {
        NEUTRAL,
        BLACK,
        RED,
        YELLOW,
        BLUE,
        GREEN,
        PURPLE
    }


}

package datasource {
    +interface StandardInput {
        +read(): Object
    }

    +class PictureLoader {
        +PictureLoader(filePath: String)
        +read(): Object
    }

    PictureLoader .u.|> StandardInput
}

@enduml

