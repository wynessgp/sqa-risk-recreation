@startuml RiskDesign

package presentation {
    +class Main {
        +{static} main(args: String[]): void
        +start(): void
    }

    +interface GenericUI {
        +draw(): void
    }

    +class ConcreteUI {

    }

    ConcreteUI .u.|> GenericUI

    +interface GenericController {
        +receiveInput(): void
    }

    +class ConcreteController {

    }

    ConcreteController .u.|> GenericController

    +class PlayerDisplay {

    }

}

package domain {
    +class WorldDominationGameEngine {
        -{static}{final} MINIMUM_NUM_PLAYERS
        -{static}{final} MAXIMUM_NUM_PLAYERS

        -{static}{final} MAXIMUM_ARMIES_POSSIBLE_IN_SETUP
        -{static}{final} ADDITIONAL_PLAYER_ARMY_OFFSET
        -{static}{final} PLAYER_LIST_SIZE_OFFSET

        -{static}{final} INITIAL_NUM_UNCLAIMED_TERRITORIES

        -playersList: List<PlayerColor>
        -playersMap: Map<PlayerColor, Player>
        -currentPlayer: PlayerColor

        -numUnclaimedTerritoriesLeft: int
        -totalUnplacedArmiesLeft: int

        -territoryGraph: TerritoryGraph
        -currentGamePhase: GamePhase

        +WorldDominationGameEngine()
        -initializeGraph(): boolean

        +initializePlayersList(playerOrder: List<PlayerColor>): boolean
        -handleErrorCheckingForOrderSize(playerOrder: List<PlayerColor>): void
        -handleErrorCheckingForOrderContents(playerOrder: List<PlayerColor>): void
        -initializePlayerColorToPlayerMap(playerColors: List<PlayerColor>): void

        +assignSetupArmiesToPlayers(): boolean
        -checkIfPlayersListIsEmpty(): void
        -handleArmyAssignment(numPlayersInGame: int): void

        +checkIfPlayerOwnsTerritory(relevantTerritory: TerritoryType, playerColor: PlayerColor): boolean
        -getPlayerInControlOfTerritory(relevantTerritory: TerritoryType): PlayerColor

        +placeNewArmiesInTerritory(relevantTerritory: TerritoryType, numArmiesToPlace: int): boolean

        -handleScramblePhaseArmyPlacement(relevantTerritory: TerritoryType, numArmiesToPlace: int): void
        -checkIfTerritoryIsUnclaimed(relevantTerritory: TerritoryType): void
        -checkNumArmiesToPlaceIsValid(numArmiesToPlace: int): void
        -checkIfPlayerHasEnoughArmiesToPlace(numArmiesToPlace: int): void
        -addTerritoryToCurrentPlayerCollection(relevantTerritory: TerritoryType): void
        -updateCurrentPlayer(): void
        -checkScramblePhaseEndCondition(): void
        -calculateNumUnplacedArmiesLeft(): void

        -handleSetupPhaseArmyPlacement(relevantTerritory: TerritoryType, numArmiesToPlace: int): void
        -checkNumArmiesToPlaceIsValidForSetup(numArmiesToPlace: int): void
        -checkIfCurrentPlayerOwnsTerritory(relevantTerritory: TerritoryType): void
        -modifyNumArmiesInTerritory(relevantTerritory: TerritoryType, additionalArmies: int): void
        -modifyNumArmiesCurrentPlayerHasToPlace(numArmiesToPlace: int): void
        -checkSetupPhaseEndCondition(): void

        ~provideCurrentPlayerForTurn(currentlyGoingPlayer: PlayerColor): void
        ~setGamePhase(gamePhase: GamePhase): void
        ~setPlayerOrderList(playersList: List<PlayerColor>): void
        ~provideMockedPlayerObjects(mockedPlayers: List<Player>): void
        ~getNumArmiesByPlayerColor(playerColor: PlayerColor): int
        ~provideMockedTerritoryGraph(mockedGraph: TerritoryGraph): void
        ~getClaimedTerritoriesForPlayer(playerInQuestion: PlayerColor): Set<TerritoryType>
        ~getPlayerOrder(): List<PlayerColor>
        +getCurrentPlayer(): PlayerColor
        +getCurrentGamePhase(): GamePhase
    }

    WorldDominationGameEngine --> "*" Player

    +class Player {
        -{final} playerColor: PlayerColor
        -numArmiesToPlace: int
        -{final} claimedTerritories: Set<TerritoryType>
        +Player(playerColor: PlayerColor)
        +getTerritories(): Set<TerritoryType>
        +setNumArmiesToPlace(newAmount: int): void
        +getColor(): PlayerColor
        +getNumArmiesToPlace(): int
        +addTerritoryToCollection(relevantTerritory: TerritoryType): void
    }

    Player --> PlayerColor
    Player --> "*" TerritoryType

    +enum GamePhase {
        SCRAMBLE
        SETUP
        PLACEMENT
        ATTACK
        FORTIFY
        GAME_OVER
    }

    WorldDominationGameEngine --> GamePhase
    WorldDominationGameEngine --> TerritoryGraph
    WorldDominationGameEngine ..> TerritoryType
    WorldDominationGameEngine ..> PlayerColor

    +class RiskCardDeck {
        -deckOfCards: List<Card>
        -{final} random: Random
        +RiskCardDeck()
        ~RiskCardDeck(random: Random)
        ~initDeck(): boolean
        -addTerritoryCards(): void
        -addWildCards(): void
        +drawCard(): Card
        ~shuffle(): boolean
        ~setDeck(deck: List<Card>): void
        ~isDeckEmpty(): boolean
    }

    +class Die {
        -maximumPossibleRoll: int
        -minimumPossibleRoll: int
        +Die(maximumPossibleRoll: int, minimumPossibleRoll: int)
        +rollSingleDie(randomizer: Random): Integer
    }

    +class DieRollParser {
        -{static} {final} MINIMUM_DIE_ROLL: int
        -{static} {final} MAXIMUM_DIE_ROLL: int
        -{static} {final} MINIMUM_AMOUNT_OF_SETUP_DICE: int
        -{static} {final} MAXIMUM_AMOUNT_OF_SETUP_DICE: int
        -{static} {final} MINIMUM_VALID_AMOUNT_OF_ATTACKER_OR_DEFENDER_DICE: int
        -{static} {final} MAXIMUM_VALID_AMOUNT_OF_DEFENDER_DICE: int
        -{static} {final} MAXIMUM_VALID_AMOUNT_OF_ATTACKER_DICE: int
        -{final} attackerDice: List<Die>
        -{final} defenderDice: List<Die>
        -{final} randomizer: Random
        -setupDie: Die

        +DieRollParser()
        +buildDiceLists(): boolean
        +rollDiceToDeterminePlayerOrder(amountOfDiceToRoll: int): List<Integer>
        -buildSetupDie(setupDieUpperBound: int): void
        +rollAttackerDice(amountOfDiceToRoll: int): List<Integer>
        +rollDefenderDice(amountOfDiceToRoll: int): List<Integer>
        -validateRequestedAmountOfDiceToRollIsInRange(requestedAmount: int, minAllowedAmount: int, maxAllowedAmount: int): void
        -rollDiceFromList(amountOfDiceToRoll: int, List<Die> listToUse)
        +generateBattleResults(defenderRolls: List<Integer>, attackerRolls: List<Integer>): List<BattleResult>
        -validateListsAreNotEmpty(defenderRollsList: List<Integer>, attackerRollsList: List<Integer>): void
        -validateListsAreSortedProperly(defenderRollsList: List<Integer>, attackerRollsList: List<Integer>): void
        -calculateBattleResult(defenderRoll: Integer, attackerRoll: Integer): BattleResult
        ~validateSortIsInNonIncreasingOrder(toCheck: List<Integer>): boolean

        // {method} the below constructor is for unit testing purposes only!
        ~DieRollParser(randomizer: Random, attackerDice: List<Die>, defenderDice: List<Die>)
    }

    DieRollParser --> "*" Die
    DieRollParser ..> BattleResult

    +enum BattleResult {
        ATTACKER_VICTORY
        DEFENDER_VICTORY
    }


    +class TradeInParser {
        -setsTradedIn: int
        +startTrade(cards: Set<Card>): int
        +getMatchedTerritories(player: Player, cards: Set<Card>): Set<TerritoryType>
        -checkTradeInState(cards: Set<Card>): void
        -hasOneOfEachType(cards: Set<Card>): boolean
        -hasThreeOfSameType(cards: Set<Card>): boolean
        -countPieceType(cards: Set<Card>, type: PieceType): long
        -hasWild(cards: Set<Card>): boolean
        ~setSetsTradedIn(setsTradedIn: int): void
    }

    TradeInParser .d.> Card
    TradeInParser ..> Player

    +enum PieceType {
        ARTILLERY
        CAVALRY
        INFANTRY
    }

    +interface Card {
        +isWild(): boolean
        +matchesTerritory(territory: TerritoryType): boolean
        +matchesPieceType(pieceType: PieceType): boolean
    }

    +class WildCard {
        +matchesTerritory(territory: TerritoryType): boolean
        +matchesPieceType(pieceType: PieceType): boolean
        +isWild(): boolean
    }

    note "matchesPieceType and isWild returns true, matchesTerritory returns false" as N1
    N1 .u. WildCard

    +class TerritoryCard {
        -territoryType: TerritoryType
        -pieceType: PieceType
        +matchesTerritory(territory: TerritoryType): boolean
        +matchesPieceType(pieceType: PieceType): boolean
        +isWild(): boolean
    }

    TerritoryCard --> PieceType
    TerritoryCard --> TerritoryType

    TerritoryCard ..|> Card
    WildCard ..|> Card
    RiskCardDeck --> "*" Card

    +enum TerritoryType {
        ...
    }

    +class TerritoryGraph {
        -territories: Map<TerritoryType, Set<Territory>>
        -territoryTypeToObject: Map<TerritoryType, Territory>
        +TerritoryGraph()

        +getTerritory(territoryType: TerritoryType): Territory
        +findAdjacentTerritories(territoryType: TerritoryType): Set<Territory>

        +addNewTerritory(territory: Territory): boolean
        +addNewAdjacency(startingTerritory: TerritoryType, endingTerritory: TerritoryType): boolean
        -isValidAdjacency(startingTerritory: TerritoryType, endingTerritory: TerritoryType): boolean

        +addSetOfAdjacencies(keyToAddOn: TerritoryType, adjTerritories: Set<Territory>): boolean
        -graphContainsAdjacencies(territoryType: TerritoryType, adjacencies: Set<TerritoryType>, currentAdjacencies: Set<TerritoryType>): boolean
        -graphHasAdjacencyMapping(adjacencies: Set<TerritoryType>, currentAdjacencies: Set<TerritoryType>): boolean
        -addAdjacenciesToGraph(territory: TerritoryType, adjacencies: Set<TerritoryType>, currentAdjacencies: Set<TerritoryType>): void
    }

    TerritoryGraph --> "*" Territory
    TerritoryGraph --> "*" TerritoryType

    +class Territory {
        -territoryType: TerritoryType
        -playerInControl: PlayerColor
        -numArmiesPresent: int

        +Territory(territoryType: TerritoryType)
        ~Territory(playerToBeInControl: Player, territoryType: TerritoryType)
        +setPlayerInControl(newPlayer: Player): boolean 
        +setNumArmiesPresent(newAmount: int): boolean
        +getPlayerInControl(): Player
        +getArmies(): int
        +getTerritoryType(): TerritoryType
    }

    Territory --> PlayerColor
    Territory --> TerritoryType

    +enum PlayerColor {
        SETUP
        BLACK
        RED
        YELLOW
        BLUE
        GREEN
        PURPLE
    }

}

package datasource {
    +interface FileLoader {
        +open(fileName: String): boolean
        +getFileUrl(): URL
    }

    +class ImageFileLoader {
        -{static} {final} IMAGE_DIRECTORY: String

        +open(fileName: String): boolean
        -checkFileExistence(fileName: String, file: URL): void
        +getFileUrl(): URL
    }

    +class SceneFileLoader {
        -sceneFile: URL

        +open(fileName: String): boolean
        -checkFileExistence(file: URL): void
        +getFileUrl(): URL
    }

    +class StyleSheetLoader {
        -cssFile: URL

        +open(fileName: String): boolean
        -createFilePointer(fileName: String): URL
        -checkFileExistence(file: URL): void
        +getFileUrl(): URL
    }

    ImageFileLoader ..|> FileLoader
    SceneFileLoader ..|> FileLoader
    StyleSheetLoader ..|> FileLoader

    +class StringsBundleLoader {
        -{static} {final} BUNDLE_NAME: String
        -{static} {final} INSTANCE: StringsBundleLoader
        -localeName: String

        -openBundle(locale: String): boolean
        -getResourceBundle(): ResourceBundle
        +{static} open(locale: String): boolean
        +{static} getBundle(): ResourceBundle
    }
}

@enduml